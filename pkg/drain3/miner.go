package drain3

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"
)

type TemplateMiner struct {
	drain        *Drain
	persistence  PersistenceHandler
	lastSaveTime time.Time
}

func NewTemplateMiner(drain *Drain, persistence PersistenceHandler) *TemplateMiner {
	return &TemplateMiner{
		drain:        drain,
		persistence:  persistence,
		lastSaveTime: time.Now(),
	}
}

func (m *TemplateMiner) AddLogMessage(ctx context.Context, content string) (ClusterUpdateType, *LogCluster, string, int, error) {
	logCluster, updateType, err := m.drain.AddLogMessage(content)
	if err != nil {
		return ClusterUpdateTypeNone, nil, "", 0, err
	}

	templateMined := logCluster.GetTemplate()
	clusterCount := len(m.drain.IdToCluster.Keys())

	if updateType != ClusterUpdateTypeNone {
		if err := m.SaveState(ctx); err != nil {
			return ClusterUpdateTypeNone, nil, "", 0, fmt.Errorf("failed to save state: %w", err)
		}
	}

	return updateType, logCluster, templateMined, clusterCount, nil
}

func (m *TemplateMiner) Match(content string, strategy SearchStrategy) (*LogCluster, error) {
	return m.drain.Match(content, strategy)
}

func (m *TemplateMiner) GetParameterList(logTemplate, logMessage string) []string {
	// extract parameters from a log message according to a provided template that was generated by calling `AddLogMessage()`
	// this function is deprecated. please use ExtractParameters instead
	// return: an ordered list of parameter values present in the log message

	extractedParameters := m.ExtractParameters(logTemplate, logMessage)
	if extractedParameters == nil || len(extractedParameters) == 0 {
		return []string{}
	}

	results := []string{}
	for _, param := range extractedParameters {
		results = append(results, param.Value)
	}
	return results
}

func (m *TemplateMiner) ExtractParameters(logTemplate, logMessage string) []*ExtractedParameter {
	// extract parameters from a log message according to a provided template that was generated by calling `AddLogMessage()`

	for _, delimiter := range m.drain.ExtraDelimiters {
		logMessage = regexp.MustCompile(delimiter).ReplaceAllString(logMessage, " ")
	}

	templateRegex, paramGroupNameToMaskName := m.getTemplateParameterExtractionRegex(logTemplate)

	// parameters are represented by specific named groups inside templateRegex
	parameterMatch := regexp.MustCompile(templateRegex).FindStringSubmatch(logMessage)

	// log template does not match template
	if parameterMatch == nil {
		return nil
	}

	// create list of extracted parameters
	extractedParameters := []*ExtractedParameter{}
	for groupName, parameter := range getNamedCaptures(regexp.MustCompile(templateRegex), parameterMatch) {
		if maskName, ok := paramGroupNameToMaskName[groupName]; ok {
			extractedParameters = append(extractedParameters, &ExtractedParameter{
				Value:    parameter,
				MaskName: maskName,
			})
		}
	}

	return extractedParameters
}

func (m *TemplateMiner) getTemplateParameterExtractionRegex(logTemplate string) (string, map[string]string) {
	paramGroupNameToMaskName := make(map[string]string)
	paramNameCounter := 0

	getNextParamName := func() string {
		paramGroupName := fmt.Sprintf("p_%d", paramNameCounter)
		paramNameCounter++
		return paramGroupName
	}

	// create a named group with the respective patterns for the given mask-name
	createCaptureRegex := func(maskName string) string {
		allowedPatterns := []string{}

		if maskName == "*" {
			allowedPatterns = append(allowedPatterns, `.+?`)
		}

		// give each capture group a unique name to avoid conflict
		paramGroupName := getNextParamName()
		paramGroupNameToMaskName[paramGroupName] = maskName
		joinedPatterns := strings.Join(allowedPatterns, "|")
		captureRegex := fmt.Sprintf(`(?P<%s>%s)`, paramGroupName, joinedPatterns)

		return captureRegex
	}

	// for every mask in the template, replace it with a named group of all possible masking-patterns it could represent (in order)
	maskNames := make(map[string]bool)
	// the drain catch-all mask
	maskNames["*"] = true

	templateRegex := regexp.QuoteMeta(logTemplate)

	// replace each mask name with a proper regex that captures it
	for maskName := range maskNames {
		searchStr := "<" + regexp.QuoteMeta(maskName) + ">"

		for {
			repStr := createCaptureRegex(maskName)
			// replace one-by-one to get a new param group name for each replacement
			templateRegexNew := strings.Replace(templateRegex, searchStr, repStr, 1)
			// break when all replaces for this mask are done
			if templateRegexNew == templateRegex {
				break
			}
			templateRegex = templateRegexNew
		}
	}

	// match also messages with multiple spaces or other whitespace chars between tokens
	templateRegex = regexp.MustCompile(`\\ `).ReplaceAllString(templateRegex, `\\s+`)
	templateRegex = "^" + templateRegex + "$"

	return templateRegex, paramGroupNameToMaskName
}

func (m *TemplateMiner) LoadState(ctx context.Context) error {
	state, err := m.persistence.Load(ctx)
	if err != nil {
		return fmt.Errorf("failed to load with persistence: %w", err)
	} else if state == nil || len(state) == 0 {
		return fmt.Errorf("saved state not found")
	}

	var loadedDrain *Drain
	if err := json.Unmarshal(state, &loadedDrain); err != nil {
		return fmt.Errorf("failed to unmarshal state: %w", err)
	}

	m.drain = loadedDrain
	return nil
}

func (m *TemplateMiner) SaveState(ctx context.Context) error {
	state, err := json.Marshal(m.drain)
	if err != nil {
		return fmt.Errorf("failed to marshal json: %w", err)
	}

	if err := m.persistence.Save(ctx, state); err != nil {
		return fmt.Errorf("failed to save with persistence: %w", err)
	}

	return nil
}

func getNamedCaptures(regex *regexp.Regexp, match []string) map[string]string {
	namedCaptures := make(map[string]string)

	for i, name := range regex.SubexpNames() {
		if i != 0 && name != "" {
			namedCaptures[name] = match[i]
		}
	}

	return namedCaptures
}

type ExtractedParameter struct {
	Value    string
	MaskName string
}
